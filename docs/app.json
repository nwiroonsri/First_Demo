[{"name":"app.R","content":"#\r\n# This is a Shiny web application. You can run the application by clicking\r\n# the 'Run App' button above.\r\n#\r\n# Find out more about building applications with Shiny here:\r\n#\r\n#    https://shiny.posit.co/\r\n#\r\n\r\nlibrary(shiny)\r\nlibrary(e1071)\r\nlibrary(mclust)\r\n#library(ggplot2)\r\n#library(UniversalCVI)\r\n#library(BayesCVI)\r\n#data(AirPassengers)\r\n#R1_data <- UniversalCVI::R1_data\r\n# UI ----\r\ndata(\"R1_data\", package = \"UniversalCVI\")\r\n\r\nWvalid = function (x, kmax, kmin = 2, method = \"kmeans\", corr = \"pearson\", \r\n          nstart = 100, sampling = 1, NCstart = TRUE) \r\n{\r\n  if (missing(x)) \r\n    stop(\"Missing input argument. A numeric data frame or matrix is required\")\r\n  if (missing(kmax)) \r\n    stop(\"Missing input argument. A maximum number of clusters is required\")\r\n  if (!is.numeric(kmax)) \r\n    stop(\"Argument 'kmax' must be numeric\")\r\n  if (kmax > nrow(x)) \r\n    stop(\"The maximum number of clusters for consideration should be less than or equal to the number of data points in dataset.\")\r\n  if (!any(method == c(\"kmeans\", \"hclust_complete\", \"hclust_average\", \r\n                       \"hclust_single\"))) \r\n    stop(\"Argument 'method' should be one of 'kmeans', 'hclust_complete', 'hclust_average' or 'hclust_single'\")\r\n  if (!any(corr == c(\"pearson\", \"kendall\", \"spearman\"))) \r\n    stop(\"Argument 'corr' should be one of 'pearson', 'kendall', 'spearman'\")\r\n  if (method == \"kmeans\") {\r\n    if (!is.numeric(nstart)) \r\n      stop(\"Argument 'nstart' must be numeric\")\r\n  }\r\n  if (!is.numeric(sampling)) \r\n    stop(\"Argument 'sampling' must be numeric\")\r\n  if (!(sampling > 0 & sampling <= 1)) \r\n    stop(\"'sampling' must be greater than 0 and less than or equal to 1\")\r\n  if (sampling == 1) {\r\n    x = x\r\n  }\r\n  else {\r\n    sample = sample(1:(nrow(x)), ceiling(nrow(x) * sampling), \r\n                    replace = FALSE)\r\n    x = x[sample, ]\r\n  }\r\n  if (!is.logical(NCstart)) \r\n    stop(\"Argument 'NCstart' must be logical\")\r\n  dm = dim(x)\r\n  d = as.vector(dist(x))\r\n  crr = rep(0, kmax - kmin + 2)\r\n  if (NCstart) {\r\n    dtom = sqrt(rowSums((x - colMeans(x))^2))\r\n    crr[1] = sd(dtom)/(max(dtom) - min(dtom))\r\n  }\r\n  if (startsWith(method, \"hclust_\")) {\r\n    H.model = hclust(dist(x), method = sub(\"hclust_\", \"\", \r\n                                           method))\r\n  }\r\n  if (kmin == 2) {\r\n    lb = 2\r\n  }\r\n  else {\r\n    lb = kmin - 1\r\n  }\r\n  for (k in lb:(kmax + 1)) {\r\n    xnew = matrix(0, dm[1], dm[2])\r\n    centroid = matrix(0, k, dm[2])\r\n    if (method == \"kmeans\") {\r\n      K.model = kmeans(x, k, nstart = nstart)\r\n      cluss = K.model$cluster\r\n      xnew = K.model$centers[cluss, ]\r\n    }\r\n    else if (startsWith(method, \"hclust_\")) {\r\n      cluss = cutree(H.model, k)\r\n      for (j in 1:k) {\r\n        if (is.null(nrow(x[cluss == j, ])) | sum(nrow(x[cluss == \r\n                                                        j, ])) == 1) {\r\n          centroid[j, ] = as.numeric(x[cluss == j, ])\r\n        }\r\n        else {\r\n          centroid[j, ] = colMeans(x[cluss == j, ])\r\n        }\r\n      }\r\n      xnew = centroid[cluss, ]\r\n    }\r\n    if (!all(seq(k) %in% unique(cluss))) \r\n      warning(\"Some clusters are empty.\")\r\n    d2 = as.vector(dist(xnew))\r\n    crr[k - kmin + 2] = cor(d, d2, method = corr)\r\n  }\r\n  K = length(crr)\r\n  NWI = ((crr[2:(K - 1)] - crr[1:(K - 2)])/(1 - crr[1:(K - \r\n                                                         2)]))/pmax(0, (crr[3:K] - crr[2:(K - 1)])/(1 - crr[2:(K - \r\n                                                                                                                 1)]))\r\n  NWI2 = (crr[2:(K - 1)] - crr[1:(K - 2)])/(1 - crr[1:(K - \r\n                                                         2)]) - (crr[3:K] - crr[2:(K - 1)])/(1 - crr[2:(K - 1)])\r\n  NWI3 = NWI\r\n  if (max(NWI) < Inf) {\r\n    if (min(NWI) == -Inf) {\r\n      NWI3[NWI == -Inf] = min(NWI[is.finite(NWI)])\r\n    }\r\n  }\r\n  if (max(NWI) == Inf) {\r\n    NWI3[NWI == Inf] = max(NWI[is.finite(NWI)]) + NWI2[NWI == \r\n                                                         Inf]\r\n    NWI3[NWI < Inf] = NWI[NWI < Inf] + NWI2[NWI < Inf]\r\n    if (min(NWI) == -Inf) {\r\n      NWI3[NWI == -Inf] = min(NWI[is.finite(NWI)]) + NWI2[NWI == \r\n                                                            -Inf]\r\n    }\r\n  }\r\n  NWI = data.frame(cbind(k = kmin:kmax, NCI1 = NWI))\r\n  NWI2 = data.frame(cbind(k = kmin:kmax, NCI2 = NWI2))\r\n  NWI3 = data.frame(cbind(k = kmin:kmax, NCI = NWI3))\r\n  crr = data.frame(cbind(k = (kmin - 1):(kmax + 1), NC = crr))\r\n  my_list <- list(NC = crr, NCI = NWI3, NCI1 = NWI, NCI2 = NWI2)\r\n  return(my_list)\r\n}\r\n\r\nB_Wvalid = function (x, kmax, method = \"kmeans\", corr = \"pearson\", nstart = 100, \r\n          sampling = 1, NCstart = TRUE, alpha = \"default\", mult.alpha = 1/2) \r\n{\r\n  if (missing(x)) \r\n    stop(\"Missing input argument. A numeric data frame or matrix is required\")\r\n  if (missing(kmax)) \r\n    stop(\"Missing input argument. A maximum number of clusters is required\")\r\n  if (!is.numeric(kmax)) \r\n    stop(\"Argument 'kmax' must be numeric\")\r\n  if (kmax > nrow(x)) \r\n    stop(\"The maximum number of clusters for consideration should be less than or equal to the number of data points in dataset.\")\r\n  if (!any(method == c(\"kmeans\", \"hclust_complete\", \"hclust_average\", \r\n                       \"hclust_single\"))) \r\n    stop(\"Argument 'method' should be one of 'kmeans', 'hclust_complete', 'hclust_average' or 'hclust_single'\")\r\n  if (!any(corr == c(\"pearson\", \"kendall\", \"spearman\"))) \r\n    stop(\"Argument 'corr' should be one of 'pearson', 'kendall', 'spearman'\")\r\n  if (method == \"kmeans\") {\r\n    if (!is.numeric(nstart)) \r\n      stop(\"Argument 'nstart' must be numeric\")\r\n  }\r\n  if (!is.numeric(sampling)) \r\n    stop(\"Argument 'sampling' must be numeric\")\r\n  if (!(sampling > 0 & sampling <= 1)) \r\n    stop(\"'sampling' must be greater than 0 and less than or equal to 1\")\r\n  if (sampling == 1) {\r\n    x = x\r\n  }\r\n  else {\r\n    sample = sample(1:(nrow(x)), ceiling(nrow(x) * sampling), \r\n                    replace = FALSE)\r\n    x = x[sample, ]\r\n  }\r\n  if (!is.logical(NCstart)) \r\n    stop(\"Argument 'NCstart' must be logical\")\r\n  if (!is.numeric(mult.alpha)) \r\n    stop(\"Argument 'mult.alpha' must be numeric\")\r\n  n = nrow(x)\r\n  kmin = 2\r\n  if (any(alpha %in% \"default\")) {\r\n    alpha = rep(1, length(kmin:kmax))\r\n  }\r\n  if (length(kmin:kmax) != length(alpha)) \r\n    stop(\"The length of kmin to kmax must be equal to the length of alpha\")\r\n  adj.alpha = alpha * (n)^mult.alpha\r\n  dm = dim(x)\r\n  d = as.vector(dist(x))\r\n  crr = rep(0, kmax - kmin + 2)\r\n  if (NCstart) {\r\n    dtom = sqrt(rowSums((x - colMeans(x))^2))\r\n    crr[1] = sd(dtom)/(max(dtom) - min(dtom))\r\n  }\r\n  if (startsWith(method, \"hclust_\")) {\r\n    H.model = hclust(dist(x), method = sub(\"hclust_\", \"\", \r\n                                           method))\r\n  }\r\n  if (kmin == 2) {\r\n    lb = 2\r\n  }\r\n  else {\r\n    lb = kmin - 1\r\n  }\r\n  for (k in lb:(kmax + 1)) {\r\n    xnew = matrix(0, dm[1], dm[2])\r\n    centroid = matrix(0, k, dm[2])\r\n    if (method == \"kmeans\") {\r\n      K.model = kmeans(x, k, nstart = nstart)\r\n      cluss = K.model$cluster\r\n      xnew = K.model$centers[cluss, ]\r\n    }\r\n    else if (startsWith(method, \"hclust_\")) {\r\n      cluss = cutree(H.model, k)\r\n      for (j in 1:k) {\r\n        if (is.null(nrow(x[cluss == j, ])) | sum(nrow(x[cluss == \r\n                                                        j, ])) == 1) {\r\n          centroid[j, ] = as.numeric(x[cluss == j, ])\r\n        }\r\n        else {\r\n          centroid[j, ] = colMeans(x[cluss == j, ])\r\n        }\r\n      }\r\n      xnew = centroid[cluss, ]\r\n    }\r\n    if (!all(seq(k) %in% unique(cluss))) \r\n      warning(\"Some clusters are empty.\")\r\n    d2 = as.vector(dist(xnew))\r\n    crr[k - kmin + 2] = cor(d, d2, method = corr)\r\n  }\r\n  K = length(crr)\r\n  NWI = ((crr[2:(K - 1)] - crr[1:(K - 2)])/(1 - crr[1:(K - \r\n                                                         2)]))/pmax(0, (crr[3:K] - crr[2:(K - 1)])/(1 - crr[2:(K - \r\n                                                                                                                 1)]))\r\n  NWI2 = (crr[2:(K - 1)] - crr[1:(K - 2)])/(1 - crr[1:(K - \r\n                                                         2)]) - (crr[3:K] - crr[2:(K - 1)])/(1 - crr[2:(K - 1)])\r\n  NWI3 = NWI\r\n  if (max(NWI) < Inf) {\r\n    if (min(NWI) == -Inf) {\r\n      NWI3[NWI == -Inf] = min(NWI[is.finite(NWI)])\r\n    }\r\n  }\r\n  if (max(NWI) == Inf) {\r\n    NWI3[NWI == Inf] = max(NWI[is.finite(NWI)]) + NWI2[NWI == \r\n                                                         Inf]\r\n    NWI3[NWI < Inf] = NWI[NWI < Inf] + NWI2[NWI < Inf]\r\n    if (min(NWI) == -Inf) {\r\n      NWI3[NWI == -Inf] = min(NWI[is.finite(NWI)]) + NWI2[NWI == \r\n                                                            -Inf]\r\n    }\r\n  }\r\n  CVI.dframe = data.frame(C = kmin:kmax, Index = NWI3)\r\n  minGI = min(CVI.dframe[, \"Index\"])\r\n  rk = (CVI.dframe[, \"Index\"] - minGI)/sum(CVI.dframe[, \"Index\"] - \r\n                                             minGI)\r\n  nrk = n * rk\r\n  ex = (adj.alpha + nrk)/(sum(adj.alpha) + n)\r\n  var = ((adj.alpha + nrk) * (sum(adj.alpha) + n - adj.alpha - \r\n                                nrk))/((sum(adj.alpha) + n)^2 * (sum(adj.alpha) + n + \r\n                                                                   1))\r\n  BCVI = data.frame(k = kmin:kmax, BCVI = ex)\r\n  VarBCVI = data.frame(k = kmin:kmax, Var = var)\r\n  colnames(CVI.dframe) = c(\"k\", \"NCI\")\r\n  WI.result = list(BCVI = BCVI, VAR = VarBCVI, Index = CVI.dframe)\r\n  return(WI.result)\r\n}\r\n\r\nui <- fluidPage(\r\n  \r\n  # App title ----\r\n  titlePanel(\"Clustering via Cluster Validity Indices by Nathakhun Wiroonsri\"),\r\n  sidebarLayout(\r\n    sidebarPanel(width = 3,\r\n                 selectInput(inputId = \"clus_alg\",\r\n                             label = \"Select Clustering Algorithm\",\r\n                             choices = c(\"K-Means\", \"Hierarchical Clustering\", \"Fuzzy C-Means\"),\r\n                             selected = \"K-Means\"),\r\n                 selectInput(inputId = \"cvi_opt\",\r\n                             label = \"Select CVI style\",\r\n                             choices = c(\"Traditional\", \"Bayesian\"),\r\n                             selected = \"Traditional\"),\r\n                 # Kmeans + Traditional\r\n                 conditionalPanel(condition = \"input.clus_alg == 'K-Means' && input.cvi_opt == 'Traditional'\",\r\n                                  numericInput(inputId = \"kmax\",\r\n                                               label = \"Kmax:\",\r\n                                               min = 2,\r\n                                               max = 20,\r\n                                               value = 10,\r\n                                               step = 1)\r\n                                 ),\r\n                 # Kmeans + Bayesian\r\n                 conditionalPanel(condition = \"input.clus_alg == 'K-Means' && input.cvi_opt == 'Bayesian'\",\r\n                                  numericInput(inputId = \"kmax2\",\r\n                                              label = \"Kmax:\",\r\n                                              min = 2,\r\n                                              max = 20,\r\n                                              value = 10,\r\n                                              step = 1),\r\n                                  sliderInput(inputId = \"k1\",\r\n                                              label = \"1st Preferred K (<= Kmax)\",\r\n                                              min = 2,\r\n                                              max = 20,\r\n                                              value = c(2,3),\r\n                                              step = 1),\r\n                                  sliderInput(inputId = \"kl1\",\r\n                                              label = \"Level of Preference\",\r\n                                              min = 0,\r\n                                              max = 3,\r\n                                              value = 1,\r\n                                              step = 1),\r\n                                  sliderInput(inputId = \"k2\",\r\n                                              label = \"2nd Preferred K (<= Kmax)\",\r\n                                              min = 2,\r\n                                              max = 20,\r\n                                              value = c(2,3),\r\n                                              step = 1),\r\n                                  sliderInput(inputId = \"kl2\",\r\n                                              label = \"Level of Preference\",\r\n                                              min = 0,\r\n                                              max = 3,\r\n                                              value = 0,\r\n                                              step = 1),\r\n                                  sliderInput(inputId = \"k3\",\r\n                                              label = \"3rd Preferred K (<= Kmax)\",\r\n                                              min = 2,\r\n                                              max = 20,\r\n                                              value = c(2,3),\r\n                                              step = 1),\r\n                                  sliderInput(inputId = \"kl3\",\r\n                                              label = \"Level of Preference\",\r\n                                              min = 0,\r\n                                              max = 3,\r\n                                              value = 0,\r\n                                              step = 1)\r\n                                  ),\r\n                 # ARIMA model arguments\r\n                 conditionalPanel(condition = \"input.model == 'ARIMA'\",\r\n                                  h5(\"Order Parameters\"),\r\n                                  sliderInput(inputId = \"p\",\r\n                                              label = \"p:\",\r\n                                              min = 0,\r\n                                              max = 5,\r\n                                              value = 0),\r\n                                  sliderInput(inputId = \"d\",\r\n                                              label = \"d:\",\r\n                                              min = 0,\r\n                                              max = 5,\r\n                                              value = 0),\r\n                                  sliderInput(inputId = \"q\",\r\n                                              label = \"q:\",\r\n                                              min = 0,\r\n                                              max = 5,\r\n                                              value = 0),\r\n                                  h5(\"Seasonal Parameters:\"),\r\n                                  sliderInput(inputId = \"P\",\r\n                                              label = \"P:\",\r\n                                              min = 0,\r\n                                              max = 5,\r\n                                              value = 0),\r\n                                  sliderInput(inputId = \"D\",\r\n                                              label = \"D:\",\r\n                                              min = 0,\r\n                                              max = 5,\r\n                                              value = 0),\r\n                                  sliderInput(inputId = \"Q\",\r\n                                              label = \"Q:\",\r\n                                              min = 0,\r\n                                              max = 5,\r\n                                              value = 0)\r\n                 ),\r\n                 # Holt Winters model arguments\r\n                 conditionalPanel(condition = \"input.model == 'Holt-Winters'\",\r\n                                  checkboxGroupInput(inputId = \"hw_args\", \r\n                                                     label = \"Select Holt-Winters Parameters:\", \r\n                                                     choices = list(\"Beta\" = 2, \r\n                                                                    \"Gamma\" = 3),\r\n                                                     selected = c(1, 2, 3)),\r\n                                  selectInput(inputId = \"hw_seasonal\",\r\n                                              label = \"Select Seasonal Type:\",\r\n                                              choices = c(\"Additive\", \"Multiplicative\"),\r\n                                              selected = \"Additive\")),\r\n                 \r\n                 actionButton(inputId = \"pushstart\", label = \"Start\")\r\n                 \r\n    ),\r\n    \r\n    # Main panel for displaying outputs ----\r\n    mainPanel(\r\n      \r\n      # Output: Formatted text for caption ----\r\n      h3(textOutput(\"caption\")),\r\n      \r\n      # Output: Plot of the requested variable against mpg ----\r\n      plotOutput(\"fc_plot\", width = \"600px\", height = \"600px\")\r\n      \r\n    )\r\n  )\r\n)\r\n\r\n\r\n# Define server logic required to draw a histogram ----\r\nserver <- function(input, output) {\r\n  dat = R1_data[,-3]\r\n  dats = scale(dat)\r\n  \r\n \r\n\r\n  # The forecasting models execute under the plot render\r\n\r\n  \r\n  \r\nobserveEvent(input$pushstart, {\r\n  \r\n   if (input$clus_alg == \"K-Means\" && input$cvi_opt == \"Traditional\"){\r\n     ww = Wvalid(dats, kmax = input$kmax)\r\n     res = kmeans(dat,ww$NCI[which.max(ww$NCI[,2]),1],nstart = 100)\r\n      output$fc_plot <- renderPlot({\r\n        cols = rainbow(input$kmax)\r\n        plot(dat,col = cols[res$cluster])\r\n      })\r\n   } else if (input$clus_alg == \"K-Means\" && input$cvi_opt == \"Bayesian\"){\r\n     aa = rep(1,input$kmax-1)\r\n     aa[(input$k1[1]-1):(input$k1[2]-1)] = aa[(input$k1[1]-1):(input$k1[2]-1)] + 10*input$kl1*aa[(input$k1[1]-1):(input$k1[2]-1)]\r\n     aa[(input$k2[1]-1):(input$k2[2]-1)] = aa[(input$k2[1]-1):(input$k2[2]-1)] + 10*input$kl2*aa[(input$k2[1]-1):(input$k2[2]-1)]\r\n     aa[(input$k3[1]-1):(input$k3[2]-1)] = aa[(input$k3[1]-1):(input$k3[2]-1)] + 10*input$kl3*aa[(input$k3[1]-1):(input$k3[2]-1)]\r\n     ww = B_Wvalid(dats, kmax = input$kmax, alpha = aa)\r\n     res = kmeans(dat,ww$BCVI[which.max(ww$BCVI[,2]),1],nstart = 100)\r\n     output$fc_plot <- renderPlot({\r\n       cols = rainbow(input$kmax)\r\n       plot(dat,col = cols[res$cluster]) \r\n     })\r\n  }\r\n})\r\n  \r\n  \r\n  \r\n  \r\n}\r\n\r\n# Create Shiny app ----\r\nshinyApp(ui = ui, server = server)","type":"text"},{"name":"First_Demo.Rproj","content":"Version: 1.0\r\n\r\nRestoreWorkspace: Default\r\nSaveWorkspace: Default\r\nAlwaysSaveHistory: Default\r\n\r\nEnableCodeIndexing: Yes\r\nUseSpacesForTab: Yes\r\nNumSpacesForTab: 2\r\nEncoding: UTF-8\r\n\r\nRnwWeave: Sweave\r\nLaTeX: pdfLaTeX\r\n","type":"text"}]
